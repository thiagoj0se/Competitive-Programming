#include <bits/stdc++.h>

#define pb push_back
#define pp pop_back
#define mp make_pair
#define lwb lower_bound
#define upb upper_bound
#define all(E) E.begin(), E.end()
#define e_min min_element
#define e_max max_element
#define bin_s binary_search
#define ff find

using namespace std;
typedef unsigned long long ll;
typedef vector<ll> vct;
typedef vector< vct > ADL;

#define MAX (1<<14)

ADL graph(MAX);
vct path, parent(MAX, 0),
    appear(MAX, 0), height(MAX, 0);
ll visited = 0;

class SparseTable {
private:
public:
    ADL SpT;
    vct Arr;
    SparseTable(ll N, vct &arr) {
        SpT.resize(N), Arr.resize(N);
        for(ll i = 0; i < N; i++) {
            Arr[i] = arr[i];
            SpT[i].resize(log2(N)+1);
            SpT[i][0] = i;
        }
        for(ll j = 1; (1<<j) <= N; j++) {
            for(ll i = 0; i + (1<<j) - 1 < N; i++) {
                if(Arr[SpT[i][j-1]] < Arr[SpT[i+(1<<(j-1))][j-1]])
                    SpT[i][j] = SpT[i][j-1];
                else
                    SpT[i][j] = SpT[i+(1<<(j-1))][j-1];
            }
        }
    }
    ll LCA(ll i, ll j) {
        ll k = log2(j-i+1);
        if(Arr[SpT[i][k]] < Arr[SpT[j-(1<<k)+1][k]])
            return SpT[i][k];
        else
            return SpT[j-(1<<k)+1][k];
    }
};

void EulerTour(ll cur, ll h) {
    appear[cur] = ++visited;
    path.pb(appear[cur]);
    height[cur] = h;
    for(ll i=0; i<graph[cur].size(); i++) {
        ll nxt = graph[cur][i];
        if(appear[nxt])
            continue;
        parent[nxt] = cur;
        EulerTour(nxt, h+1);
        path.pb(appear[cur]);
    }
}

int main() {
    ll N, M, v1, v2;
    cin >> N >> M;
    for(ll i=0;i<N-1; i++) {
        cin >> v1 >> v2;
        graph[v1].pb(v2);
        graph[v2].pb(v1);
    }
    EulerTour(1, 0);
    for(ll i=0; i<path.size(); i++)
        cout << path[i] << " ";
    cout << endl;
    SparseTable calc(path.size(), path);
    for(ll i=0; i<M; i++) {
        cin >> v1 >> v2;
        cout << appear[v1] << " " << appear[v2] << endl;
        int reas =  calc.LCA( min(appear[v1], appear[v2]),
                            max(appear[v1], appear[v2]));
        for(ll i=0; i<N; i++)
            if(appear[i] == reas)
                cout << reas << endl;
    }
    return 0;
}
